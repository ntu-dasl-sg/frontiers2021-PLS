---
title: "PLS_Wei"
author: "Maricar L. Rabonza"
date: "10/14/2021"
output: html_document
---

Hazard model source: GEM, Stevens, et al for PSHA for Kathmandu, Simulated with OpenQuake
Link to paper: https://pubs.geoscienceworld.org/ssa/bssa/article-abstract/108/6/3488/548195/Probabilistic-Seismic-Hazard-Assessment-of
Link to data repository: https://vickystevens.shinyapps.io/Nepal_seismichazard/
Downloaded 15 October 2021
Resolution: 0.15 deg


```{r setup, include=FALSE}
#------------------------------------------
# Set working libraries
#------------------------------------------
library(here) # sets location of .RProj as working directory
library(knitr) # useful for many rmarkdown layout functions
library(raster) # handling rasters
library(dplyr) # data wrangling
library(reshape) # data wrangling
library(ggplot2) # the ultimate plotter
library(geosphere)
library(sp) # raster plotting # needed for extract
library(sf)
library(gstat) # helps with geostatistics and kriging
library(plotly) # another nice plotter
library(automap) # gives out pretty variogram plots
library(DescTools) # reverse dataframe order
library(viridis) # for colour-blind palette
library(scico) # more scientific palette
library(fields) # for image.plot legends
library(xtable) # export table to latex
library(metR) # allows usage of geom_text_contour in ggplot
library(maps)
library(maptools)
library(grid)
library(xml2)
#install.packages("ggridges")
library(ggridges)
#library(tidyverse)
```


Initiate

```{r}
# Set seed
set.seed(42)
# Define map projection of all spatial data
map_proj <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"
```

Read data.

```{r}
# Read Nepal school dataset
dat_allbldgs <- read.csv( here( "data","Exposure_School_Hosp_Nepal.csv"), head=TRUE, sep=",")
```

Read Gorkha PGA data

```{r}
# Read from downloaded folder
pga <- read.csv( here( "data","shaking_model", "stevens", "PSHA_Kathmandu_10.csv"), head=TRUE, sep=",")
```

```{r}
# Read from downloaded folder
pga <- read.csv( here( "data","shaking_model", "stevens", "PSHA_Kathmandu_10.csv"), head=TRUE, sep=",")

colnames(pga) <- c("lon", "lat", "pga")

ggplot() +
    geom_raster(data = pga, aes(x = lon, y = lat, fill = pga)) +
    scale_fill_scico(palette = 'bilbao', name = "PGA (%g)", direction = 1) +
     geom_point(data = dat_allbldgs, aes(x = Lat, y = Lon), alpha = 0.9, size = 1.5, colour="black") +
    labs(x = "Longitude", y = "Latitude") +
    # xlim(85.0, 85.7) + # set map bounds along x
    # ylim(27.4, 27.95) + # set map bounds along y
    coord_quickmap()+
    theme_bw()
```



Here we use all buildings with shaking data available.
Filter schools only and save as `dat_ret.school`

```{r}
# View list of all building categories. This is useful for the next line of code
bldg.categories <- unique(dat_allbldgs$building_usage)
bldg.categories

# Get subset of educational facilities
dat_allsch <- filter(dat_allbldgs,
                     building_usage == "school" |
                     building_usage == "college" |
                     building_usage == "kindergarten" |
                     building_usage == "university" )

# Filter of retrofitted schools
# dat_ret.school <- dat_allsch %>% filter(retrofit=='Yes')

# We only use buildings with known retrofit state 
dat_ret.school <- dat_allsch %>% filter(retrofit != "N/A")

# Get columns of interest
dat_ret.school <- data.frame(lat=dat_ret.school$Lon,  #note the original database mistook lon as lat, and vice versa
                             lon=dat_ret.school$Lat, 
                             num_flr = dat_ret.school$num_floors,
                             occupants_day = dat_ret.school$occupants_day, 
                             occupants_morning = dat_ret.school$occupants_morning,
                             occupants_evening=dat_ret.school$occupants_evening,
                             occupants_night=dat_ret.school$occupants_night,
                             retrofit = dat_ret.school$retrofit,
                             struc_type = dat_ret.school$structur_type)

# The data has two columns for day occupants, and two columns for night occupants
# Here, we just retain whichever is larger.
dat_ret.school$occ_day <- pmax(dat_ret.school$occupants_day, dat_ret.school$occupants_morning)
dat_ret.school$occ_night <- pmax(dat_ret.school$occupants_evening, dat_ret.school$occupants_night)
dropcols <- c("occupants_morning","occupants_evening")
dat_ret.school <- dat_ret.school[ , !(names(dat_ret.school) %in% dropcols)]

# For the study, we'll not use the evening occupancy, just the day. 
# Remove rows with no occupancy values during the day
dat_ret.school$occ_day[dat_ret.school$occ_day==""] <- NA #Replace empty cells with NA
dat_ret.school <- na.omit(dat_ret.school, cols="occ_day") # Remove if day occupancy = NA
dat_ret.school$occ_day <- as.numeric(dat_ret.school$occ_day) # Set occupancy numbers as numeric
dat_ret.school <- dat_ret.school %>% filter(occ_day != 0) # Remove if day occupancy = 0
dat_ret.school <- dat_ret.school %>% filter(occ_day != "No") #Remove rows with invalid entries
dat_ret.school <- dat_ret.school %>% filter(occ_day != "hall") #Remove rows with invalid entries
dat_ret.school <- dat_ret.school %>% filter(occ_day != "NA") #Remove rows with invalid entries

# Remove rows with unknown number of floors. 
# We consider number of floors in assigning the building fragility curve
dat_ret.school$num_flr <- as.numeric(dat_ret.school$num_flr)
dat_ret.school <- na.omit(dat_ret.school, cols="num_flr") # Remove NA

# Drop columns we don't need hereon. 
dropcols <- c("occupants_day","occupants_night", "occ_night")
dat_ret.school <- dat_ret.school[ , !(names(dat_ret.school) %in% dropcols)]

# We don't have fragility curves for buildings more than 5 floors. So we drop them
dat_ret.school<- dat_ret.school %>% filter(num_flr<6)

# There is a building with 38140 occupants. Maybe this is a type, but we remove this data point so as not to inflate our results
dat_ret.school<- dat_ret.school %>% filter(occ_day!=38140)

# here, I choose to remove 2 buildings with occupancy larger than 2000, so as not to inflate results
dat_ret.school<- dat_ret.school %>% filter(occ_day!=6030)
dat_ret.school<- dat_ret.school %>% filter(occ_day!=3510)

# We also filter the buildings with materials that we can classify. Make sure there are no invalid types
dat_ret.school <- dat_ret.school %>% filter(struc_type=='Load_Bearing_Brick_Wall_in_Mud_Mortar'  |
                                         struc_type=='Load_Bearing_Stone_Wall_in_Mud_Mortar'  |
                                         struc_type=='Load_Bearing_Brick_Wall_in_Cement_Mortar' |
                                         struc_type=='Load_Bearing_Stone_Wall_in_Cement_Mortar' |
                                         struc_type=='Mud_Brick_in_Surkhi' |
                                         struc_type=='Mixed' |
                                         struc_type=='Engineered_RC_Frame' |
                                         struc_type=='Non_Engineered_RC_Frame'|
                                         struc_type=='Adobe')

# Summary stats check
summary(dat_ret.school$num_flr)
summary(dat_ret.school$occ_day)
unique(dat_ret.school$retrofit)
unique(dat_ret.school$struc_type)

```

Plot hazard map and retrofitted schools

```{r}
ggplot() +
    geom_raster(data = pga, aes(x = lon, y = lat, fill = pga)) +
    scale_fill_scico(palette = 'bilbao', name = "PGA (%g)", direction = 1) +
     geom_point(data = dat_ret.school, aes(x = lon, y = lat), alpha = 0.9, size = 1.5, colour="black") +
    labs(x = "Longitude", y = "Latitude") +
    # xlim(85.0, 85.7) + # set map bounds along x
    # ylim(27.4, 27.95) + # set map bounds along y
    coord_quickmap()+
    theme_bw()
```

Extract model values at building point locations
This also removes the points outside of the psha map

```{r}

# Convert building locations to SPDF (Spatial Points Data Frame)
pts.ret.school <- dat_ret.school
coordinates(pts.ret.school) <- c("lon", "lat")  # set columns for coordinates
proj4string(pts.ret.school) <- CRS(map_proj) # define projection 
plot(pts.ret.school)

# Convert PGA csv data to raster
coordinates(pga) = ~lon+lat
proj4string(pga) = CRS("+init=epsg:4326")
g <- raster(pga)  ## gives an empty 10*10 grid on your extent/crs
res(g) <- c(0.00833, 0.00834)  ## set the resolution (pixel size x/y)
## rasterize by "value" column with na.rm optionally
# This won't interpolate at all, it's just n-points to 1-cell by point-in-cell membership
r <- rasterize(pga, g, field = pga$pga, fun = mean, na.rm = TRUE)
# Convert raster to dataframe for plotting with ggplot
pts.raster <- rasterToPoints(r)  # change to rasterToPoints(r.pga) for a full map
pga <-  data.frame(pts.raster)
r.pga <- rasterFromXYZ(pga)
#plot(r.pga)

# Extract prediction at point locations
pga.at.points <- raster::extract(x = r.pga, # the raster that you wish to extract values from
                       y = pts.ret.school, #point locations
                       method = 'simple', # If 'simple' values for the cell a point falls in are returned.
                       #buffer = 0, # specify buffer in meters if preferred
                       na.rm=TRUE,
                       sp =T # T means create spatial object 
)
pga.at.points <- as.data.frame(pga.at.points) # store extracted values to a new column named "pga"

# Remove buildings with NA pga
names(pga.at.points)=c("lat","lon","num_flr", "retrofit", "struc_type", "occ_day", "pga")
pga.at.points <- pga.at.points %>% filter(pga != "NA") #Remove rows with NA # if error occurs, check column name if it's 'layer' or 'pga'
pga.at.points  <- na.omit(pga.at.points, cols="pga") # Remove if pga = NA

summary(pga.at.points$pga)

write.csv(pga.at.points,
          file= here("data", "building_port_5011.csv"),
          row.names = F)

# Add pga column with pga value but in character with 3 decimal places
# This makes matching of data frames easier on the next sections
pga.at.points$pga <- formatC( round(pga.at.points$pga, 3 ), format='f', digits=3 )

# Make sure occupancy column is numeric
pga.at.points$occ_day <- as.numeric(pga.at.points$occ_day)

```

Write raster
```{r}
crs(r.pga) <- crs(map_proj)
writeRaster(r.pga, filename= here("data", "raster_psha10.tif"), overwrite=TRUE)
```


Assign building types to the structural types given in the database
Unretrofitted types: B, B-, C2-, K5-
Retrofitted: C3

```{r}
# Type B (Unretrofitted) : All mud mortar&stone up to 1 storey, All cement up to 3 storey
bldgs_B<- pga.at.points %>% filter(struc_type=='Load_Bearing_Brick_Wall_in_Mud_Mortar' & num_flr==1 |
                                       struc_type=='Load_Bearing_Stone_Wall_in_Mud_Mortar' & num_flr==1 |
                                       struc_type=='Adobe' & num_flr==1 |
                                       struc_type=='Load_Bearing_Brick_Wall_in_Cement_Mortar' & num_flr <=3 |
                                       struc_type=='Load_Bearing_Stone_Wall_in_Cement_Mortar' & num_flr <=3 |
                                       struc_type=='Mud_Brick_in_Surkhi' & num_flr==1 )

# Type B- (Unretrofitted) : All mud mortar&stone up to 3 storey, All cement up to 5 storey
bldgs_Bm <- pga.at.points %>% filter(struc_type=='Load_Bearing_Brick_Wall_in_Mud_Mortar' & num_flr>1 |
                                         struc_type=='Load_Bearing_Stone_Wall_in_Mud_Mortar' & num_flr>1 |
                                         struc_type=='Adobe' & num_flr>1 |
                                         struc_type=='Load_Bearing_Brick_Wall_in_Cement_Mortar' & num_flr >3 |
                                         struc_type=='Load_Bearing_Stone_Wall_in_Cement_Mortar' & num_flr >3 |
                                         struc_type=='Mud_Brick_in_Surkhi' & num_flr>1 |
                                         struc_type=='Mixed' & num_flr>=1 )

# Type C2- (Unretrofitted) : Reinforced concrete engineered / engineered less than five floors
bldgs_C2 <- pga.at.points %>% filter(struc_type=='Engineered_RC_Frame' & num_flr <=3 |
                                         struc_type=='Non_Engineered_RC_Frame'  & num_flr <=3) # since in the database, no building is more than 5 floors

# Type K5- (Unretrofitted) : Reinforced concrete engineered / engineered with five floors
bldgs_K5 <- pga.at.points %>% filter(struc_type=='Engineered_RC_Frame' & num_flr >3 |
                                         struc_type=='Non_Engineered_RC_Frame'  & num_flr>3  )


bldgs_C3 <- pga.at.points %>% filter(struc_type=='Load_Bearing_Brick_Wall_in_Mud_Mortar'  |
                                       struc_type=='Adobe'  |
                                         struc_type=='Load_Bearing_Stone_Wall_in_Mud_Mortar'  |
                                         struc_type=='Load_Bearing_Brick_Wall_in_Cement_Mortar' |
                                         struc_type=='Load_Bearing_Stone_Wall_in_Cement_Mortar' |
                                         struc_type=='Mud_Brick_in_Surkhi' |
                                         struc_type=='Mixed' |
                                         struc_type=='Engineered_RC_Frame' |
                                         struc_type=='Non_Engineered_RC_Frame' )
```

Generate fragility curves (collapse damage state) for each building type

```{r}
PGA <- seq(0,3,0.001)

# Set params
frag_B <- list(collapse=list(param1=1.0661326, param2=0.8576781))
frag_Bm <- list(collapse=list(param1=1.1294012, param2=0.7901519))
frag_C2 <- list(collapse=list(param1=-0.1369917, param2=0.7716791))
frag_K5 <- list(collapse=list(param1=1.1176457, param2=1.1176457))
frag_C3 <- list(collapse=list(param1=-0.758287, param2=0.4448039)) #actual values for c3

# Caculate probabilities
prob_B <- pnorm(frag_B[["collapse"]][["param1"]] + frag_B[["collapse"]][["param2"]] * log(PGA))
prob_Bm <- pnorm(frag_Bm[["collapse"]][["param1"]] + frag_Bm[["collapse"]][["param2"]] * log(PGA))
prob_C2 <- pnorm(frag_C2[["collapse"]][["param1"]] + frag_C2[["collapse"]][["param2"]] * log(PGA))
prob_K5 <- pnorm(frag_K5[["collapse"]][["param1"]] + frag_K5[["collapse"]][["param2"]] * log(PGA))
prob_C3 <- pnorm(frag_C3[["collapse"]][["param1"]] + frag_C3[["collapse"]][["param2"]] * log(PGA))

# Make data frames for fragility curves
fcurv_B <- data.frame(pga=PGA, frag=prob_B)
fcurv_Bm <- data.frame(pga=PGA, frag=prob_Bm)
fcurv_C2 <- data.frame(pga=PGA, frag=prob_C2)
fcurv_K5 <- data.frame(pga=PGA, frag=prob_K5)
fcurv_C3 <- data.frame(pga=PGA, frag=prob_C3)

# change pga column to character with 3 decimal places
fcurv_B$pga <- formatC( round(fcurv_B$pga, 3 ), format='f', digits=3 )
fcurv_Bm$pga <- formatC( round(fcurv_Bm$pga, 3 ), format='f', digits=3 )
fcurv_C2$pga <- formatC( round(fcurv_C2$pga, 3 ), format='f', digits=3 )
fcurv_K5$pga <- formatC( round(fcurv_K5$pga, 3 ), format='f', digits=3 )
fcurv_C3$pga <- formatC( round(fcurv_C3$pga, 3 ), format='f', digits=3 )
```

Plot all fragility curves

```{r}

# Collect all fragility curves to one dataframe
frag_all <- data.frame (PGA = PGA,
                        prob_B= prob_B,
                        prob_Bm= prob_Bm,
                        prob_C2=prob_C2,
                        prob_K5=prob_K5,
                        prob_C3=prob_C3)
# Rename columns
names(frag_all)=c("PGA","B","B-", "C2", "K5", "C3")
# Reshape for plotting
frag_all.melt <- melt(frag_all,id.vars = "PGA")
# Add column to differentiate non-retrofitted and unretrofitted
frag_all.melt <- cbind(frag_all.melt,type=c(rep("Non-Retrofitted",length(PGA)*4),rep("Retrofitted",length(PGA)*1)))
#Rename columns
names(frag_all.melt)=c("PGA","Building_type","value", "type")

# Plot
ggplot(data=frag_all.melt)+
    geom_line(aes(x=PGA, y=value, col=type,
                  linetype=Building_type))+
    scale_color_manual(values=c("#c41a00", "#142b5c"), name="Building state")+
    scale_linetype_manual(values=c(1,2,3,4,5), name="Building type") +  
    labs(x="Peak ground acceleration (%g)",
         y = "Probability of Exceeding Collapse Damage",
         title="Collapse fragility curves for school buildings in Nepal"
    )  +
    annotate(geom="text", x=2.5, y=0,
           label="Data source: (JICA, 2002)") +
    theme(panel.background = element_rect(fill = NA),
          panel.grid.major = element_line(colour = "snow2"),
          panel.grid.minor = element_line(colour = "snow2"),
          panel.border = element_blank(),
          plot.title = element_text(face = "bold"),
          #legend.position=c(.85, .18),
          axis.line = element_line(colour = "black"))
# Save file
ggsave(file= here("graphics", "fragility_allcurves.png"),
       width = 5, height = 3,
       scale =1.5,
       dpi = 300)

```


Get probability of exceeding damage at each building point

```{r}
# Match PGA values extracted from the raster to that in the fragility curve
prob_dmg_B <- merge(bldgs_B, fcurv_B, by.x='pga')
prob_dmg_Bm <- merge(bldgs_Bm, fcurv_Bm, by.x='pga')
prob_dmg_C2 <- merge(bldgs_C2, fcurv_C2, by.x='pga')
prob_dmg_K5 <- merge(bldgs_K5, fcurv_K5, by.x='pga')
prob_dmg_C3 <- merge(bldgs_C3, fcurv_C3, by.x='pga')

# Insert lable for building class based on fragiltiy cuyrve
prob_dmg_B$class <- "B"
prob_dmg_Bm$class <- "Bm"
prob_dmg_C2$class <- "C2"
prob_dmg_K5$class <- "K5"
prob_dmg_C3$class <- "C3"

# Combine rows of building corresponding to UNRETROFITTED case
all_unret <- rbind(prob_dmg_B,
                   prob_dmg_Bm,
                   prob_dmg_C2,
                   prob_dmg_K5)

# Combine rows of building corresponding to RETROFITTED case
all_ret <- rbind(prob_dmg_C3)

```


Write csv

```{r}
all_unret$occ_day <- as.numeric(all_unret$occ_day)
all_unret$box <- "box"
ggplot(all_unret, aes(y=box, x=occ_day)) +
  geom_boxplot(outlier.shape = 1)+
  #geom_jitter(alpha=0.2, shape=1)+
  guides(fill=FALSE) + #remove legend
  labs(x="Building occupancy",
       y="",
       title="Building occupancy of 5011 retrofitted school buildings")+
    theme(panel.background = element_rect(fill = "white", color="black"),
          panel.border = element_blank(),
          plot.background = element_rect(fill = "transparent",colour = NA),
          axis.ticks.length.x = unit(.25, "cm"),
          panel.grid.minor.y = element_blank(),
          panel.grid.major.y = element_blank(),
          panel.grid.minor.x = element_blank(),
          panel.grid.major.x = element_blank(),
          text=element_text(color="white"),
          axis.text=element_text(color="white"),
          axis.ticks = element_line(colour = "white", size = 1)
  )
ggsave(file= here("graphics", "case2_occupancy.png") ,
       width = 5.5, height = 2,
       scale =1,
       dpi = 300,
       bg = "transparent")

summary(all_unret$occ_day)
summary(all_ret$occ_day)
#boxplot(all_unret$occ_day ~ all_unret$retrofit ,)

```

Violin plot of occupancy

```{r}
all_unret$occ_day <- as.numeric(all_unret$occ_day)
all_unret$box <- "box"
ggplot(all_unret, aes(y=box, x=occ_day)) +
    geom_violin(fill = "khaki2")+
    geom_boxplot(outlier.shape = 1, width = .2)+
    guides(fill=FALSE) + #remove legend
  labs(x="Building occupancy",
       y="",
       title="Building occupancy of 70 retrofitted school buildings")+
    theme(panel.background = element_rect(fill = "white", color="black"),
          panel.border = element_blank(),
          plot.background = element_rect(fill = "transparent",colour = NA),
          axis.ticks.length.x = unit(.25, "cm"),
          panel.grid.minor.y = element_blank(),
          panel.grid.major.y = element_blank(),
          panel.grid.minor.x = element_blank(),
          panel.grid.major.x = element_blank(),
          text=element_text(color="white"),
          axis.text=element_text(color="white"),
          axis.ticks = element_line(colour = "white", size = 1)
  )

ggsave(file= here("graphics", "case2_occ_violin.png") ,
       width = 5.5, height = 2,
       scale =1,
       dpi = 300,
       bg = "transparent")


```


Bar plot of building types 
```{r}
## set the levels in order we want
all_unret <- within(all_unret, 
                   class <- factor(class, 
                                      levels=c("C2", "K5", "B", "Bm")))


ggplot(all_unret, aes(y=class)) +
  geom_bar()+
  labs(y="Building Type",
       x="Count",
       title="Building type distribution for 5011 retrofitted school buildings")+
  theme(panel.background = element_rect(fill = "white"),
          panel.border = element_blank()
  )
ggsave(file= here("graphics", "case2_bldgtype.png") ,
       #plot = last_plot(),
       bg = "white",
       width = 5, height = 3,
       scale =1.2,
       dpi = 300)

summary(all_unret$class)

table(all_ret$struc_type)
table(all_unret$struc_type)

write.csv(all_unret,
          file= here("data", "building_port_5011_class.csv"),
          row.names = F)

```

Algorithm check to execute Monte Carlo with rbinom 

With rbinom, the function works like:
arguments:
n = number of observations
size = number of trials
prob = probability of success
https://www.programmingr.com/examples/neat-tricks/sample-r-function/r-rbinom/
https://stackoverflow.com/questions/49647529/binomial-distribution-by-row-using-r

```{r}

# Get number of buildings
bldg_count <- nrow(all_unret) # no. of rows of all_unret & all_ret the same

# Simple example: For one building with probability of exceedance of 0.70 at a specific PGA. 
# Then we look at its collapse for 1000 Monte carlo trials
a <- rbinom(1, 1000, 0.7)
a # number of times the building collapsed

# For all 70 buildings, but for n=1 Monte carlo trial
n=1
c1.rand_bin <- matrix(nrow=bldg_count,ncol=n) # Make matrix for binary numbers, 0 and 1. 1 if collapse, 0 not collapse
prob_collapse_unret <- all_unret$frag
#prob_collapse_unret
c1.rand_bin <- rbinom(n = nrow(c1.rand_bin), 1, prob_collapse_unret)
c1.rand_bin # vector of bins of collapse of the 70 buildings

# For all 70 buildings, but for any N Monte carlo trials
n=10000
c1.rand_bin <- matrix(nrow=bldg_count,ncol=n) # Make matrix for binary numbers, 0 and 1. 1 if collapse, 0 not collapse
prob_collapse_unret <- all_unret$frag # Save the probability of exceedance of all buildings to a vector
for (i in 1:n){ #for each trial
  c1.rand_bin[,i] <- rbinom(n = nrow(c1.rand_bin), 1, prob_collapse_unret)
}
#c1.rand_bin

#Check how many times the first building collapsed
# The test-p should be more or less the same with test_rate_collapse if n is sufficiently high
test_bldgnum <- 9 # pick which building (e.g. 1 is first row in the dataframe)
test_p <- prob_collapse_unret[test_bldgnum] #probability of exceeding collapse of the building
test_vector_collapse_bin <- c1.rand_bin[test_bldgnum,] # bins of collapse of building for all the n trials
test_times_collapse <- sum(test_vector_collapse_bin) # number of times the building collapsed
test_rate_collapse <- test_times_collapse/n # number of times collapsed divide by trials


```

## CALCULATE FATALITIES - UNRETROFITTED CASE - DAY TIME

Generate Bernoulli trials - unretrofitted case #Run time = 20mins

```{r}
# Get number of buildings
bldg_count <- nrow(all_unret) # no. of rows of all_unret & all_ret the same
# Set number of Monte Carlo simulations
n <- 10000

# Generate Bernoulli trials according to the exceedance probabilities of each building to collapse
# This chunk takes time to finish
c1.rand_bin <- matrix(nrow=bldg_count,ncol=n) # Make matrix for binary numbers, 0 and 1. 1 if collapse, 0 not collapse
prob_collapse_unret <- all_unret$frag # Save the probability of exceedance of all buildings to a vector
for (i in 1:n){ #for each trial
  c1.rand_bin[,i] <- rbinom(n = nrow(c1.rand_bin), 1, prob_collapse_unret)
}

#Check number of simulations done
ncol(c1.rand_bin) 
#Check number of buildings accounted in simulation
nrow(c1.rand_bin)

```

Calculate number of collapsed buildings for each trial. Then save to a vector

```{r}

# Make empty vector for number of collapse for each trial
c1.collapse <- numeric()
c1.collapse <- colSums(c1.rand_bin,na.rm = TRUE)

# Get summary stats
summary(c1.collapse)
hist(c1.collapse)

```

Calculate number of fatalities for each trial. Then save to a vector

```{r}
# Get occupancy values of 70 buildings
c1.occ <- as.numeric(all_unret$occ_day)
# Set the assumed fatality rate
fatality_rate <- 0.20   
# Make empty matrix for occupants exposed to collapse
c1.rand_occ <- matrix(nrow=bldg_count,ncol=n)

## For each collapsed building, multiply 1s to the occupancy exposed 
for (i in 1:bldg_count){ #for each building
    for (j in 1:n){ # for each simulation
        c1.rand_occ[i,j] <- c1.occ[i] * c1.rand_bin[i,j]
    }
}

# Get the total exposed occupants to collapse for each trial
unret_occ <-colSums(c1.rand_occ) 

# Multiply exposed occupants to a fatality rate given bulding collapse
c1.occ_fat <- c1.rand_occ * fatality_rate
unret_fat <- colSums(c1.occ_fat,na.rm = TRUE) # Get the total fatalities for each trial

```

Get summary statistics - fatalities

```{r}
summary(unret_fat)
hist(unret_fat, probability = TRUE)
```


## CALCULATE FATALITIES - RETROFITTED CASE - DAY TIME

Generate Bernoulli trials - retrofitted case

```{r}
# Set number of Monte Carlo simulations
n <- 10000

# Generate Bernoulli trials according to the exceedance probabilities of each building to collapse
# This chunk takes time to finish
c2.rand_bin <- matrix(nrow=bldg_count,ncol=n) # Make matrix for binary numbers, 0 and 1. 1 if collapse, 0 not collapse
prob_collapse_ret <- all_ret$frag # Save the probability of exceedance of all buildings to a vector
for (i in 1:n){ #for each trial
  c2.rand_bin[,i] <- rbinom(n = nrow(c2.rand_bin), 1, prob_collapse_ret)
}

#Check number of simulations done
ncol(c2.rand_bin) 
#Check number of buildings accounted in simulation
nrow(c2.rand_bin)

```


Calculate number of collapsed buildings for each trial. Then save to a vector

```{r}
# Make empty vector for number of collapse for each trial
c2.collapse <- numeric()
c2.collapse <- colSums(c2.rand_bin,na.rm = TRUE)

# Get summary stats
summary(c2.collapse)
hist(c2.collapse, probability = TRUE)

```


Calculate number of fatalities for each trial. Then save to a vector

```{r}
# Get occupancy values of 70 buildings
c2.occ <- as.numeric(all_ret$occ_day) # should be same as c1.occ
# Set the assumed fatality rate
fatality_rate <- 0.20   
# Make empty matrix for occupants exposed to collapse
c2.rand_occ <- matrix(nrow=bldg_count,ncol=n)

## For each collapsed building, multiply 1s to the occupancy exposed 
for (i in 1:bldg_count){ #for each building
    for (j in 1:n){ # for each simulation
        c2.rand_occ[i,j] <- c2.occ[i] * c2.rand_bin[i,j]
    }
}

# Get the total exposed occupants to collapse for each trial
ret_occ <-colSums(c2.rand_occ,na.rm = TRUE) 

# Multiply exposed occupants to a fatality rate given bulding collapse
c2.occ_fat <- c2.rand_occ * fatality_rate
ret_fat <- colSums(c2.occ_fat,na.rm = TRUE) # Get the total fatalities for each trial

```

Get summary statistics - fatalities

```{r}
summary(ret_fat)
hist(ret_fat, probability = TRUE)
```



## DENSITY PLOTS - FATALITIES for Unretrofitted and Retrofitted

Load RData if starting here
```{r}
load(here("RData_psha","c1.collapse.RData"))
load(here("RData_psha","c2.collapse.RData"))
load(here("RData_psha","unret_fat.RData"))
load(here("RData_psha","ret_fat.RData"))
load(here("RData_psha","c1.occ.RData"))
bldg_count <- length(c1.occ)
fatality_rate = 0.2
n = 10000
```

Statistics to show for plotting
```{r}
# Create the function to get mode
getmode <- function(v) { 
    uniqv <- unique(v)
    uniqv[which.max(tabulate(match(v, uniqv)))]
}

# Statistics for building collapse
mode_unret_coll <- getmode(c1.collapse)
mean_unret_coll <- mean(c1.collapse)
mode_ret_coll <- getmode(c2.collapse)
mean_ret_coll <- mean(c2.collapse)

# Statistics for fatalities
mode_unret_fat <- getmode(unret_fat)
mean_unret_fat <- mean(unret_fat)
mode_ret_fat <- getmode(ret_fat)
mean_ret_fat <- mean(ret_fat)

# Calculate lives saved
LivesSaved <- round(mean_unret_fat) - round(mean_ret_fat)

# Total occupancy
tot.occ <- sum(c1.occ) # should be the same with either c1 or c2

# Number of fatalities if all buildings collapsed, with the assumed the fatality rate 
tot.fat <- tot.occ * fatality_rate



```

```{r}
# Reshape data frames for plotting
fatality_all <- data.frame(index = c(1:n),
                           Counterfactual=unret_fat,
                           Actual=ret_fat)
fatality.melt <- melt(fatality_all, id.vars = "index")
names(fatality.melt)=c("index","Building_state","Fatalities")

```


GGRIDGES

```{r}

library("scales")
# Density plot with semi-transparent fill
ggplot(fatality.melt, aes(x=Fatalities, y=Building_state, fill=Building_state, color=Building_state)) +
  geom_density_ridges(quantile_lines=TRUE, quantile_fun=function(x,...)mean(x),
                      scale = 1, alpha=0.9,
                      color="white",
                      bandwidth=200)+
    # geom_density_ridges(stat = "binline",
    #                   bins = 250,
    #                   scale = 0.95,
    #                   draw_baseline = F)+
  scale_y_discrete(expand = c(0, 0)) + 
  #scale_x_continuous(expand = c(0, 0)) +   # for both axes to remove unneeded padding
  scale_x_continuous(labels = comma_format(),
                     limits = c(0,90000))+
  scale_fill_manual(values=c("#c41a00", "#142b5c"))+
  scale_color_manual(values=c("#c41a00", "#142b5c"))+
  guides(fill=FALSE, color=FALSE) + #remove legend
  coord_cartesian(clip = "off") + # to avoid clipping of the very top of the top ridgeline
  geom_hline(yintercept = 1,color = "black", alpha=0.6)+
  geom_hline(yintercept = 2,color="black", alpha=0.6)+
  #geom_point(aes(x= mean_ret_fat, y=2 ), color = "black") +
  #geom_point(aes(x= mean_unret_fat, y=1 ), color = "black") +
  #geom_point(aes(x= mode_ret_fat, y=2 ), shape=17, size=2, color = "black") +
  #geom_point(aes(x= mode_unret_fat, y=1), shape=17, size=2, color = "black") +
  geom_segment(aes(x = mean_ret_fat, xend = mean_ret_fat, y=1, yend=2),
               linetype="dotted", 
               size=0.4, color = "grey80", alpha=0.1)+
  geom_segment(aes(x = mean_ret_fat, xend = mean_unret_fat, y=1.6, yend=1.6),
               arrow = arrow(length = unit(0.5, "cm")), linetype=1, size=0.4, color = "black")+
  geom_segment(aes(x = mean_unret_fat, xend = mean_ret_fat, y=1.6, yend=1.6),
               arrow = arrow(length = unit(0.5, "cm")), linetype=1, size=0.4, color = "black")+
  #geom_vline(xintercept = mean_ret_fat, alpha = 0.15)+
  #geom_vline(xintercept = mean_unret_fat, alpha = 0.15)+
  annotate(geom="text", x=50000, y=1.7, label=paste("Estimated lives saved =", comma(LivesSaved)), color="black", angle=0) +
  annotate(geom="text", x=67000, y=2.8, label="Estimates based on 10,000 simulations" , color="grey20", angle=0) +
  annotate(geom="text", x=60800, y=2.65, label=paste("Assumed fatality rate =", fatality_rate), color="grey20", angle=0) +
  annotate(geom="text", x=61000, y=2.5, label=paste("Total occupancy =", comma(tot.occ)), color="grey20", angle=0) +
  annotate(geom="text", x=69500, y=2.35, label=paste("Fatalities if all buildings collapsed =", comma(tot.fat)), color="grey20", angle=0) +
  #annotate(geom="text", x=mode_unret_fat-7000, y=1.1, label=paste(comma(round(mode_unret_fat))), color="grey50", angle=0) +
  #annotate(geom="text", x=mode_ret_fat-7000, y=2.1, label=paste(comma(round(mode_ret_fat))), color="grey50", angle=0) +
  annotate(geom="text", x=mean_unret_fat+7000, y=1.1, label=paste(comma(round(mean_unret_fat))), color="grey50", angle=0) +
  annotate(geom="text", x=mean_ret_fat+7000, y=2.1, label=paste(comma(round(mean_ret_fat))), color="grey50", angle=0) +
  #annotate(geom="text", x=mode_unret_fat-7000, y=1.2, label="mode", color="grey50", angle=0) +
  #annotate(geom="text", x=mode_ret_fat-7000, y=2.2, label="mode", color="grey50", angle=0) +
  annotate(geom="text", x=mean_unret_fat+7000, y=1.2, label="mean", color="grey50", angle=0) +
  annotate(geom="text", x=mean_ret_fat+7000, y=2.2, label="mean", color="grey50", angle=0) +
  labs(y = "Scenario",
       title = paste("Estimated fatalities for", comma(bldg_count), "school buildings")) +
  theme_ridges(center = TRUE, grid = FALSE)

ggsave(file= here("graphics", "results-case2.png") ,
       #plot = last_plot(),
       bg = "white",
       width = 7, height = 3,
       scale =1.2,
       dpi = 300)
```

```{r}
# Reshape data frames for plotting
collapse_all <- data.frame(index = c(1:n),
                           Counterfactual=c1.collapse,
                           Actual=c2.collapse)
collapse.melt <- melt(collapse_all, id.vars = "index")
names(collapse.melt)=c("index","Building_state","Collapsed_Buildings")

# Calculate building collapse saved
CollapseSaved <- round(mean_unret_coll) - round(mean_ret_coll)

summary(ret_fat)

```


```{r}
# Density plot with semi-transparent fill
ggplot(collapse.melt, aes(x=Collapsed_Buildings, y=Building_state, fill=Building_state, color=Building_state)) +
  stat_density_ridges(quantile_lines=TRUE, quantile_fun=function(x,...)mean(x),
                      scale = 1,
                      alpha=0.9,
                      color="white",
                      bandwidth=20
                      )+
  # geom_density_ridges(stat = "binline",
  #                     #bins = 70,
  #                     binwidth=20,
  #                     scale = 0.95,
  #                     draw_baseline = F)+
  scale_y_discrete(expand = c(0, 0)) + 
  scale_x_continuous(expand = c(0, 0)) +   # for both axes to remove unneeded padding
  #scale_fill_manual(values=c("#d7191c", "#2c7bb6"))+
  scale_fill_manual(values=c("#c41a00", "#142b5c"))+
  scale_color_manual(values=c("#c41a00", "#142b5c"))+
  geom_hline(yintercept = 1,color = "black", alpha=0.6)+
  geom_hline(yintercept = 2,color="black", alpha=0.6)+
  guides(fill=FALSE, color=FALSE) + #remove legend
  coord_cartesian(clip = "off") + # to avoid clipping of the very top of the top ridgeline
  # geom_point(aes(x= mean_ret_coll, y=2 ), color = "black") +
  # geom_point(aes(x= mean_unret_coll, y=1 ), color = "black") +
  # geom_point(aes(x= mode_ret_coll, y=2 ), shape=17, size=2, color = "black") +
  # geom_point(aes(x= mode_unret_coll, y=1), shape=17, size=2, color = "black") +
  geom_segment(aes(x = mean_ret_coll, xend = mean_ret_coll, y=1, yend=2),
               linetype="dotted", 
               size=0.4, color = "grey80", alpha=0.1)+
  geom_segment(aes(x = mean_ret_coll, xend = mean_unret_coll, y=1.6, yend=1.6),
               arrow = arrow(length = unit(0.5, "cm")), linetype=1, size=0.4, color = "black")+
  geom_segment(aes(x = mean_unret_coll, xend = mean_ret_coll, y=1.6, yend=1.6),
               arrow = arrow(length = unit(0.5, "cm")), linetype=1, size=0.4, color = "black")+
  #geom_vline(xintercept = mean_ret_coll, alpha = 0.15)+
  #geom_vline(xintercept = mean_unret_coll, alpha = 0.15)+
  annotate(geom="text", x=2000, y=1.7, label=paste("Avoided collapse =", comma(CollapseSaved)), color="black", angle=0) +
  annotate(geom="text", x=3000, y=2.8, label="Estimates based on 10,000 simulations" , color="grey20", angle=0) +
  #annotate(geom="text", x=mode_unret_coll+250, y=1.1, label=paste(comma(round(mode_unret_coll,0))), color="grey20", angle=0) +
  #annotate(geom="text", x=mode_ret_coll+250, y=2.1, label=paste(comma(round(mode_ret_coll,0))), color="grey20", angle=0) +
  annotate(geom="text", x=mean_unret_coll+250, y=1.1, label=paste(comma(round(mean_unret_coll,0))), color="grey20", angle=0) +
  annotate(geom="text", x=mean_ret_coll+250, y=2.1, label=paste(comma(round(mean_ret_coll,0))), color="grey20", angle=0) +
  #annotate(geom="text", x=mode_unret_coll+250, y=1.2, label="mode", color="grey20", angle=0) +
  #annotate(geom="text", x=mode_ret_coll+250, y=2.2, label="mode", color="grey20", angle=0) +
  annotate(geom="text", x=mean_unret_coll+250, y=1.2, label="mean", color="grey20", angle=0) +
  annotate(geom="text", x=mean_ret_coll+250, y=2.2, label="mean", color="grey20", angle=0) +
  xlim(c(-10,4000))+
  labs(y = "Scenario",
       x= "No. of collapsed buildings",
       title = paste("Estimated building collapse out of", comma(bldg_count), "school buildings"))+ 
  theme_ridges(center = TRUE, grid = FALSE)

ggsave(file= here("graphics", "s2_collapsedbldgs_case2.png") ,
       #plot = last_plot(),
       bg = "white",
       width = 7, height = 3,
       scale =1.2,
       dpi = 300)

```



Save RData
```{r}

save(c1.collapse, file = here("RData_psha","c1.collapse.RData"))
save(c2.collapse, file = here("RData_psha","c2.collapse.RData"))
save(unret_fat, file = here("RData_psha","unret_fat.RData"))
save(ret_fat, file = here("RData_psha","ret_fat.RData"))
save(c1.occ, file = here("RData_psha","c1.occ.RData"))

```