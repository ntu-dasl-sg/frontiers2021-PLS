---
title: "PLS_Wei"
author: "Maricar L. Rabonza"
date: "10/14/2021"
output: html_document
---

Hazard model source: USGS Shakemap for 2015 Gorhka EQ
Link: :https://earthquake.usgs.gov/earthquakes/eventpage/us20002926/shakemap/pga
Downloaded 15 October 2021
Data from the ESRI datasets category. Folder should have both the .flt and .hdr file
Units same as those in xml: ln(pctg): Percent-g (i.e., nominal Earth gravity). (in natural log units)
Resolution (lat and lon spacing): 0.0167

Algorithm - Monte Carlo Bernoulli trials


```{r setup, include=FALSE}
#------------------------------------------
# Set working libraries
#------------------------------------------
library(here) # sets location of .RProj as working directory
library(knitr) # useful for many rmarkdown layout functions
library(raster) # handling rasters
library(dplyr) # data wrangling
library(reshape) # data wrangling
library(ggplot2) # the ultimate plotter
library(geosphere)
library(sp) # raster plotting # needed for extract
library(sf)
library(gstat) # helps with geostatistics and kriging
library(plotly) # another nice plotter
library(automap) # gives out pretty variogram plots
library(DescTools) # reverse dataframe order
library(viridis) # for colour-blind palette
library(scico) # more scientific palette
library(fields) # for image.plot legends
library(xtable) # export table to latex
library(metR) # allows usage of geom_text_contour in ggplot
library(maps)
library(maptools)
library(grid)
library(xml2)
#install.packages("ggridges")
library(ggridges)
```

Initiate

```{r}
# Set seed
set.seed(42)
# Define map projection of all spatial data
map_proj <- "+init=epsg:4326 +proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0"
```

Read data

```{r}
# Read Nepal school dataset
dat_allbldgs <- read.csv( here( "data","Exposure_School_Hosp_Nepal.csv"), head=TRUE, sep=",")
```

Read Gorkha PGA data

```{r}
# Read from downloaded folder
r.pga <- raster(here( "data","shaking_model","shakemap", "raster-5", "pga_mean.flt"), sep=",")
crs(r.pga) <- crs(map_proj)
r.pga <- 10^r.pga # File is in natural log units 
#plot(r.pga) # summary(r.pga)
```

Prepare PGA raster for mapping

```{r}
#Crop raster to reduce file size (eyeballing the extents of point data)
e <- extent(85.1, 85.6, 27.5, 27.83) 
 #e <- extent(82.3, 88.3, 27.0, 29) # a bit more zoomed out
r.pga.crop <- crop(r.pga, e)

# Convert raster to dataframe for plotting with ggplot
pts.raster <- rasterToPoints(r.pga.crop)  # change to rasterToPoints(r.pga) for a full map
df.pga <-  data.frame(pts.raster)
colnames(df.pga) <- c("lon", "lat", "pga")

pga <- df.pga
summary(pga$pga)
```

Plot hazard map with all school buildings

```{r}
ggplot() +
    geom_raster(data = pga, aes(x = lon, y = lat, fill = pga)) +
    scale_fill_scico(palette = 'bilbao', name = "PGA (%g)", direction = 1) +
     geom_point(data = dat_allbldgs, aes(x = Lat, y = Lon), alpha = 0.9, size = 1.5, colour="black") +
    labs(x = "Longitude", y = "Latitude") +
    xlim(85.0, 85.7) + # set map bounds along x
    ylim(27.4, 27.95) + # set map bounds along y
    coord_quickmap()+
    theme_bw()
```

Filter retrofitted schools only and save as `dat_ret.school`
We only use schools with known occupancy, building type, and number of floors.
Then we remove unncessary columns.

```{r}
# View list of all building categories. This is useful for the next line of code
bldg.categories <- unique(dat_allbldgs$building_usage)
bldg.categories

# Get subset of educational facilities
dat_allsch <- filter(dat_allbldgs,
                     building_usage == "school" |
                     building_usage == "college" |
                     building_usage == "kindergarten" |
                     building_usage == "university" )

# Filter retrofitted schools
dat_ret.school <- dat_allsch %>% filter(retrofit=='Yes')

# Get columns of interest, and rename properly
dat_ret.school <- data.frame(lat=dat_ret.school$Lon,  #note the original database mistook lon as lat, and vice versa
                             lon=dat_ret.school$Lat, 
                             num_flr = dat_ret.school$num_floors,
                             occupants_day = dat_ret.school$occupants_day, 
                             occupants_morning = dat_ret.school$occupants_morning,
                             occupants_evening=dat_ret.school$occupants_evening,
                             occupants_night=dat_ret.school$occupants_night,
                             retrofit = dat_ret.school$retrofit,
                             struc_type = dat_ret.school$structur_type)

# The data has two columns for day occupants, and two columns for night occupants

# Here, we just retain whichever is larger to be on the conservative side
dat_ret.school$occ_day <- pmax(dat_ret.school$occupants_day, dat_ret.school$occupants_morning)
dat_ret.school$occ_night <- pmax(dat_ret.school$occupants_evening, dat_ret.school$occupants_night)
dropcols <- c("occupants_morning","occupants_evening")
dat_ret.school <- dat_ret.school[ , !(names(dat_ret.school) %in% dropcols)]

# For the study, we'll not use the evening occupancy, just the day. 
# Remove rows with no occupancy values during the day
dat_ret.school$occ_day[dat_ret.school$occ_day==""] <- "NA" #Replace empty cells with NA
dat_ret.school <- na.omit(dat_ret.school, cols="occ_day") # Remove if day occupancy = NA
dat_ret.school$occ_day <- as.numeric(dat_ret.school$occ_day) # Set occupancy numbers as numeric
dat_ret.school <- dat_ret.school %>% filter(occ_day != 0) # Remove if day occupancy = 0
dat_ret.school <- dat_ret.school %>% filter(occ_day != "No") #Remove rows with invalid entries
dat_ret.school <- dat_ret.school %>% filter(occ_day != "hall") 
dat_ret.school <- dat_ret.school %>% filter(occ_day != "NA") 

# Remove rows with unknown number of floors. 
# We consider number of floors in assigning the building fragility curve
dat_ret.school$num_flr <- as.numeric(dat_ret.school$num_flr)
dat_ret.school <- na.omit(dat_ret.school, cols="num_flr") # Remove NA

# Drop columns we don't need hereon. 
dropcols <- c("occupants_day","occupants_night", "occ_night")
dat_ret.school <- dat_ret.school[ , !(names(dat_ret.school) %in% dropcols)]

# We don't have fragility curves for buildings more than 5 floors. So we drop them
dat_ret.school<- dat_ret.school %>% filter(num_flr<6)

# We also filter the buildings with materials that we can classify. Make sure there are no invalid types
dat_ret.school <- dat_ret.school %>% filter(struc_type=='Load_Bearing_Brick_Wall_in_Mud_Mortar'  |
                                         struc_type=='Load_Bearing_Stone_Wall_in_Mud_Mortar'  |
                                         struc_type=='Load_Bearing_Brick_Wall_in_Cement_Mortar' |
                                         struc_type=='Load_Bearing_Stone_Wall_in_Cement_Mortar' |
                                         struc_type=='Mud_Brick_in_Surkhi' |
                                         struc_type=='Mixed' |
                                         struc_type=='Engineered_RC_Frame' |
                                         struc_type=='Non_Engineered_RC_Frame'|
                                         struc_type=='Adobe')

# Summary stats check
summary(dat_ret.school$num_flr)
summary(dat_ret.school$occ_day)
unique(dat_ret.school$retrofit)
unique(dat_ret.school$struc_type)

```

Plot hazard map and retrofitted schools

```{r}
ggplot() +
    geom_raster(data = pga, aes(x = lon, y = lat, fill = pga)) +
    scale_fill_scico(palette = 'bilbao', name = "PGA (%g)", direction = 1) +
     geom_point(data = dat_ret.school, aes(x = lon, y = lat), alpha = 0.9, size = 1.5, colour="black") +
    labs(x = "Longitude", y = "Latitude") +
    xlim(85.0, 85.7) + # set map bounds along x
    ylim(27.4, 27.95) + # set map bounds along y
    coord_quickmap()+
    theme_bw()
```

Extract model values at building point locations

```{r}

# Convert building locations to SPDF (Spatial Points Data Frame)
pts.ret.school <- dat_ret.school
coordinates(pts.ret.school) <- c("lon", "lat")  # set columns for coordinates
proj4string(pts.ret.school) <- CRS(map_proj) # define projection 
plot(pts.ret.school)

# Convert PGA csv data to raster
r.pga <- rasterFromXYZ(pga)
r.pga

# Extract prediction at point locations
pga.at.points <- raster::extract(x = r.pga, # the raster that you wish to extract values from
                       y = pts.ret.school, #point locations
                       method = 'simple', # If 'simple' values for the cell a point falls in are returned.
                       #buffer = 0, # specify buffer in meters if preferred
                       na.rm=TRUE,
                       sp =T # T means create spatial object 
)
pga.at.points <- as.data.frame(pga.at.points) # store extracted values to a new column named "pga"

summary(pga.at.points$pga)

# Add pga column with pga value but in character with 3 decimal places
# This makes matching of data frames easier on the next sections
pga.at.points$pga <- formatC( round(pga.at.points$pga, 3 ), format='f', digits=3 )



```


Bar plot of building types
```{r}
ggplot(pga.at.points, aes(y=struc_type)) +
geom_bar()

```


Write raster
```{r}
crs(r.pga) <- crs(map_proj)
writeRaster(r.pga, filename= here("data", "raster_shakemap.tif"), overwrite=TRUE)
```

Assign building types to the structural types given in the database
Unretrofitted types: B, B-, C2-, K5-
Retrofitted: C3

```{r}
# Type B (Unretrofitted) : All mud mortar&stone up to 1 storey, All cement up to 3 storey
bldgs_B<- pga.at.points %>% filter(struc_type=='Load_Bearing_Brick_Wall_in_Mud_Mortar' & num_flr==1 |
                                       struc_type=='Load_Bearing_Stone_Wall_in_Mud_Mortar' & num_flr==1 |
                                       struc_type=='Adobe' & num_flr==1 |
                                       struc_type=='Load_Bearing_Brick_Wall_in_Cement_Mortar' & num_flr <=3 |
                                       struc_type=='Load_Bearing_Stone_Wall_in_Cement_Mortar' & num_flr <=3 |
                                       struc_type=='Mud_Brick_in_Surkhi' & num_flr==1 ) 

# Type B- (Unretrofitted) : All mud mortar&stone up to 3 storey, All cement up to 5 storey
bldgs_Bm <- pga.at.points %>% filter(struc_type=='Load_Bearing_Brick_Wall_in_Mud_Mortar' & num_flr>1 |
                                         struc_type=='Load_Bearing_Stone_Wall_in_Mud_Mortar' & num_flr>1 |
                                         struc_type=='Adobe' & num_flr>1 |
                                         struc_type=='Load_Bearing_Brick_Wall_in_Cement_Mortar' & num_flr >3 |
                                         struc_type=='Load_Bearing_Stone_Wall_in_Cement_Mortar' & num_flr >3 |
                                         struc_type=='Mud_Brick_in_Surkhi' & num_flr>1 |
                                         struc_type=='Mixed' & num_flr>=1 )

# Type C2- (Unretrofitted) : Reinforced concrete engineered / engineered less than five floors
bldgs_C2 <- pga.at.points %>% filter(struc_type=='Engineered_RC_Frame' & num_flr <=3 |
                                         struc_type=='Non_Engineered_RC_Frame'  & num_flr <=3) # since in the database, no building is more than 5 floors

# Type K5- (Unretrofitted) : Reinforced concrete engineered / engineered with five floors
bldgs_K5 <- pga.at.points %>% filter(struc_type=='Engineered_RC_Frame' & num_flr >3 |
                                         struc_type=='Non_Engineered_RC_Frame'  & num_flr>3  )

# Retrofitted state of all RC and brick buildings
bldgs_C3 <- pga.at.points %>% filter(struc_type=='Load_Bearing_Brick_Wall_in_Mud_Mortar'  |
                                         struc_type=='Load_Bearing_Stone_Wall_in_Mud_Mortar'  |
                                         struc_type=='Load_Bearing_Brick_Wall_in_Cement_Mortar' |
                                         struc_type=='Load_Bearing_Stone_Wall_in_Cement_Mortar' |
                                         struc_type=='Mud_Brick_in_Surkhi' |
                                         struc_type=='Mixed' |
                                         struc_type=='Engineered_RC_Frame' |
                                         struc_type=='Non_Engineered_RC_Frame' )
```

Generate fragility curves (collapse damage state) for each building type

```{r}
PGA <- seq(0,3,0.001)

# Set params
frag_B <- list(collapse=list(param1=1.0661326, param2=0.8576781))
frag_Bm <- list(collapse=list(param1=1.1294012, param2=0.7901519))
frag_C2 <- list(collapse=list(param1=-0.1369917, param2=0.7716791))
frag_K5 <- list(collapse=list(param1=1.1176457, param2=1.1176457))
frag_C3 <- list(collapse=list(param1=-0.758287, param2=0.4448039)) #actual values for c3

# Caculate probabilities
prob_B <- pnorm(frag_B[["collapse"]][["param1"]] + frag_B[["collapse"]][["param2"]] * log(PGA))
prob_Bm <- pnorm(frag_Bm[["collapse"]][["param1"]] + frag_Bm[["collapse"]][["param2"]] * log(PGA))
prob_C2 <- pnorm(frag_C2[["collapse"]][["param1"]] + frag_C2[["collapse"]][["param2"]] * log(PGA))
prob_K5 <- pnorm(frag_K5[["collapse"]][["param1"]] + frag_K5[["collapse"]][["param2"]] * log(PGA))
prob_C3 <- pnorm(frag_C3[["collapse"]][["param1"]] + frag_C3[["collapse"]][["param2"]] * log(PGA))

# Make data frames for fragility curves
fcurv_B <- data.frame(pga=PGA, frag=prob_B)
fcurv_Bm <- data.frame(pga=PGA, frag=prob_Bm)
fcurv_C2 <- data.frame(pga=PGA, frag=prob_C2)
fcurv_K5 <- data.frame(pga=PGA, frag=prob_K5)
fcurv_C3 <- data.frame(pga=PGA, frag=prob_C3)

# change pga column to character with 3 decimal places
fcurv_B$pga <- formatC( round(fcurv_B$pga, 3 ), format='f', digits=3 )
fcurv_Bm$pga <- formatC( round(fcurv_Bm$pga, 3 ), format='f', digits=3 )
fcurv_C2$pga <- formatC( round(fcurv_C2$pga, 3 ), format='f', digits=3 )
fcurv_K5$pga <- formatC( round(fcurv_K5$pga, 3 ), format='f', digits=3 )
fcurv_C3$pga <- formatC( round(fcurv_C3$pga, 3 ), format='f', digits=3 )
```

Plot all fragility curves

```{r}

# Collect all fragility curves to one dataframe
frag_all <- data.frame (PGA = PGA,
                        prob_B= prob_B,
                        prob_Bm= prob_Bm,
                        prob_C2=prob_C2,
                        prob_K5=prob_K5,
                        prob_C3=prob_C3)
# Rename columns
names(frag_all)=c("PGA","B","B-", "C2", "K5", "C3")
# Reshape for plotting
frag_all.melt <- melt(frag_all,id.vars = "PGA")
# Add column to differentiate non-retrofitted and unretrofitted
frag_all.melt <- cbind(frag_all.melt,type=c(rep("Non-Retrofitted",length(PGA)*4),rep("Retrofitted",length(PGA)*1)))
#Rename columns
names(frag_all.melt)=c("PGA","Building_type","value", "type")

# Plot
ggplot(data=frag_all.melt)+
    geom_line(aes(x=PGA, y=value, col=type,
                  linetype=Building_type))+
    scale_color_manual(values=c("#c41a00", "#142b5c"), name="Building state")+
    scale_linetype_manual(values=c(1,2,3,4,5), name="Building type") +  
    labs(x="Peak ground acceleration (%g)",
         y = "Probability of Exceeding Collapse Damage",
         title="Collapse fragility curves for school buildings in Nepal"
    )  +
    annotate(geom="text", x=2.5, y=0,
           label="Data source: (JICA, 2002)") +
    theme(panel.background = element_rect(fill = NA),
          panel.grid.major = element_line(colour = "snow2"),
          panel.grid.minor = element_line(colour = "snow2"),
          panel.border = element_blank(),
          plot.title = element_text(face = "bold"),
          #legend.position=c(.85, .18),
          axis.line = element_line(colour = "black"))
# Save file
ggsave(file= here("graphics", "fragility_allcurves.png"),
       width = 5, height = 3,
       scale =1.5,
       dpi = 300)

```

```{r}
# Plot
ggplot(data=frag_all.melt)+
    geom_line(aes(x=PGA, y=value, col=type,
                  linetype=Building_type))+
    scale_color_manual(values=c("#c41a00", "#142b5c"), name="Building state")+
    scale_linetype_manual(values=c(1,2,3,4,5), name="Building type") +  
    labs(x="Peak ground acceleration (g)",
         y = "Probability of Exceeding Collapse Damage",
         title="Collapse fragility curves for school buildings in Nepal"
    )  +
    xlim(c(0,1))+
    annotate(geom="text", x=2.5, y=0,
           label="Data source: (JICA, 2002)") +
  coord_cartesian()+
    theme(panel.background = element_rect(fill = NA),
          panel.grid.major = element_line(colour = "snow2"),
          #panel.grid.minor = element_line(colour = "snow2"),
          panel.border = element_blank(),
          plot.title = element_text(face = "bold"),
          #legend.position=c(.85, .18),
          axis.line = element_line(colour = "black"))
# Save file
ggsave(file= here("graphics", "fragility_allcurves_v2.png"),
       width = 5, height = 3,
       scale =1.5,
       dpi = 300)
```



Get probability of exceeding damage at each building point

```{r}
# Match PGA values extracted from the raster to that in the fragility curve
prob_dmg_B <- merge(bldgs_B, fcurv_B, by.x='pga')
prob_dmg_Bm <- merge(bldgs_Bm, fcurv_Bm, by.x='pga')
prob_dmg_C2 <- merge(bldgs_C2, fcurv_C2, by.x='pga')
prob_dmg_K5 <- merge(bldgs_K5, fcurv_K5, by.x='pga')
prob_dmg_C3 <- merge(bldgs_C3, fcurv_C3, by.x='pga')

# Insert lable for building class based on fragiltiy cuyrve
prob_dmg_B$class <- "B"
prob_dmg_Bm$class <- "Bm"
prob_dmg_C2$class <- "C2"
prob_dmg_K5$class <- "K5"
prob_dmg_C3$class <- "C3"

# Combine rows of building corresponding to UNRETROFITTED case
all_unret <- rbind(prob_dmg_B,
                   prob_dmg_Bm,
                   prob_dmg_C2,
                   prob_dmg_K5)

# Combine rows of building corresponding to RETROFITTED case
all_ret <- rbind(prob_dmg_C3)

```

Write csv

```{r}
all_unret$occ_day <- as.numeric(all_unret$occ_day)
ggplot(all_unret, aes(y=retrofit, x=occ_day, fill= "#2c7bb6")) +
  geom_boxplot()+
  geom_jitter(alpha=0.2, shape=1)+
  guides(fill=FALSE) + #remove legend
  theme_bw()+
  labs(x="Building occupancy",
       y="",
       title="Building occupancy of 70 retrofitted school buildings")
ggsave(file= here("graphics", "case1_occupancy_shakemap.png") ,
       bg = "white",
       width = 6, height = 2,
       scale =1.2,
       dpi = 300)

summary(all_unret$occ_day)

```

Bar plot of building types 
```{r}
ggplot(all_unret, aes(y=class)) +
  geom_bar()+
  theme_bw()+
  labs(y="Building Type",
       x="Count",
       title="Building type distribution for 70 retrofitted school buildings")
ggsave(file= here("graphics", "case1_bldgtype_shakemap.png") ,
       #plot = last_plot(),
       bg = "white",
       width = 6, height = 3,
       scale =1.2,
       dpi = 300)
```

OPTIONAL TO RUN
Algorithm check to execute Monte Carlo with rbinom 

With rbinom, the function works like:
arguments:
n = number of observations
size = number of trials
prob = probability of success
https://www.programmingr.com/examples/neat-tricks/sample-r-function/r-rbinom/
https://stackoverflow.com/questions/49647529/binomial-distribution-by-row-using-r

```{r}

# Get number of buildings
bldg_count <- nrow(all_unret) # no. of rows of all_unret & all_ret the same

# Simple example: For one building with probability of exceedance of 0.70 at a specific PGA. 
# Then we look at its collapse for 1000 Monte carlo trials
a <- rbinom(1, 1000, 0.7)
a # number of times the building collapsed

# For all 70 buildings, but for n=1 Monte carlo trial
n=1
c1.rand_bin <- matrix(nrow=bldg_count,ncol=n) # Make matrix for binary numbers, 0 and 1. 1 if collapse, 0 not collapse
prob_collapse_unret <- all_unret$frag
#prob_collapse_unret
c1.rand_bin <- rbinom(n = nrow(c1.rand_bin), 1, prob_collapse_unret) # or rbinom(n = 70, 1, prob_collapse_unret)
c1.rand_bin # vector of bins of collapse of the 70 buildings

# For all 70 buildings, but for any N Monte carlo trials
n=10000
c1.rand_bin <- matrix(nrow=bldg_count,ncol=n) # Make matrix for binary numbers, 0 and 1. 1 if collapse, 0 not collapse
prob_collapse_unret <- all_unret$frag # Save the probability of exceedance of all buildings to a vector
for (i in 1:n){ #for each trial
  c1.rand_bin[,i] <- rbinom(n = nrow(c1.rand_bin), 1, prob_collapse_unret)
}
#c1.rand_bin

#Check how many times the first building collapsed
# The test-p should be more or less the same with test_rate_collapse if n is sufficiently high
test_bldgnum <- 9 # pick which building (e.g. 1 is first row in the dataframe)
test_p <- prob_collapse_unret[test_bldgnum] #probability of exceeding collapse of the building
test_vector_collapse_bin <- c1.rand_bin[test_bldgnum,] # bins of collapse of building for all the n trials
test_times_collapse <- sum(test_vector_collapse_bin) # number of times the building collapsed
test_rate_collapse <- test_times_collapse/n # number of times collapsed divide by trials


```

## CALCULATE FATALITIES - UNRETROFITTED CASE - DAY TIME

Generate Bernoulli trials - unretrofitted case

```{r}
# Set number of Monte Carlo simulations
n <- 10000
# Get number of buildings
bldg_count <- nrow(all_unret) # no. of rows of all_unret & all_ret the same

# Generate Bernoulli trials according to the exceedance probabilities of each building to collapse
# This chunk takes time to finish
c1.rand_bin <- matrix(nrow=bldg_count,ncol=n) # Make matrix for binary numbers, 0 and 1. 1 if collapse, 0 not collapse
prob_collapse_unret <- all_unret$frag # Save the probability of exceedance of all buildings to a vector
for (i in 1:n){ #for each trial
  c1.rand_bin[,i] <- rbinom(n = nrow(c1.rand_bin), 1, prob_collapse_unret)
}

#Check number of simulations done
ncol(c1.rand_bin) 
#Check number of buildings accounted in simulation
nrow(c1.rand_bin)

```

Calculate number of collapsed buildings for each trial. Then save to a vector

```{r}

# Make empty vector for number of collapse for each trial
c1.collapse <- numeric()
c1.collapse <- colSums(c1.rand_bin,na.rm = TRUE)

# Get summary stats
summary(c1.collapse)
hist(c1.collapse)

```

Calculate number of fatalities for each trial. Then save to a vector

```{r}
# Get occupancy values of 70 buildings
c1.occ <- as.numeric(all_unret$occ_day)
# Set the assumed fatality rate
fatality_rate <- 0.20   
# Make empty matrix for occupants exposed to collapse
c1.rand_occ <- matrix(nrow=bldg_count,ncol=n)

## For each collapsed building, multiply 1s to the occupancy exposed 
for (i in 1:bldg_count){ #for each building
    for (j in 1:n){ # for each simulation
        c1.rand_occ[i,j] <- c1.occ[i] * c1.rand_bin[i,j]
    }
}

# Get the total exposed occupants to collapse for each trial
unret_occ <-colSums(c1.rand_occ,na.rm = TRUE) 

# Multiply exposed occupants to a fatality rate given bulding collapse
c1.occ_fat <- c1.rand_occ * fatality_rate
unret_fat <- colSums(c1.occ_fat,na.rm = TRUE) # Get the total fatalities for each trial

```

Get summary statistics - fatalities

```{r}
summary(unret_fat)
hist(unret_fat, probability = TRUE)
```


## CALCULATE FATALITIES - RETROFITTED CASE - DAY TIME

Generate Bernoulli trials - retrofitted case

```{r}
# Set number of Monte Carlo simulations
n <- 10000

# Generate Bernoulli trials according to the exceedance probabilities of each building to collapse
# This chunk takes time to finish
c2.rand_bin <- matrix(nrow=bldg_count,ncol=n) # Make matrix for binary numbers, 0 and 1. 1 if collapse, 0 not collapse
prob_collapse_ret <- all_ret$frag # Save the probability of exceedance of all buildings to a vector
for (i in 1:n){ #for each trial
  c2.rand_bin[,i] <- rbinom(n = nrow(c2.rand_bin), 1, prob_collapse_ret)
}

#Check number of simulations done
ncol(c2.rand_bin) 
#Check number of buildings accounted in simulation
nrow(c2.rand_bin)

```


Calculate number of collapsed buildings for each trial. Then save to a vector

```{r}
# Make empty vector for number of collapse for each trial
c2.collapse <- numeric()
c2.collapse <- colSums(c2.rand_bin,na.rm = TRUE)

# Get summary stats
summary(c2.collapse)
hist(c2.collapse, probability = TRUE)

```


Calculate number of fatalities for each trial. Then save to a vector

```{r}
# Get occupancy values of 70 buildings
c2.occ <- as.numeric(all_ret$occ_day) # should be same as c1.occ
# Set the assumed fatality rate
fatality_rate <- 0.20   
# Make empty matrix for occupants exposed to collapse
c2.rand_occ <- matrix(nrow=bldg_count,ncol=n)

## For each collapsed building, multiply 1s to the occupancy exposed 
for (i in 1:bldg_count){ #for each building
    for (j in 1:n){ # for each simulation
        c2.rand_occ[i,j] <- c2.occ[i] * c2.rand_bin[i,j]
    }
}

# Get the total exposed occupants to collapse for each trial
ret_occ <-colSums(c2.rand_occ,na.rm = TRUE) 

# Multiply exposed occupants to a fatality rate given bulding collapse
c2.occ_fat <- c2.rand_occ * fatality_rate
ret_fat <- colSums(c2.occ_fat,na.rm = TRUE) # Get the total fatalities for each trial

```

Get summary statistics - fatalities

```{r}
summary(ret_fat)
hist(ret_fat, probability = TRUE)
```



## DENSITY PLOTS - FATALITIES for Unretrofitted and Retrofitted

Load RData if starting here
```{r}
load(here("RData_case1_shakemap","c1.collapse.RData"))
load(here("RData_case1_shakemap","c2.collapse.RData"))
load(here("RData_case1_shakemap","unret_fat.RData"))
load(here("RData_case1_shakemap","ret_fat.RData"))
load(here("RData_case1_shakemap","c1.occ.RData"))
bldg_count <- length(c1.occ)
fatality_rate = 0.2
n = 10000
```


Statistics to show for plotting
```{r}
# Create the function to get mode
getmode <- function(v) { 
    uniqv <- unique(v)
    uniqv[which.max(tabulate(match(v, uniqv)))]
}

# Statistics for building collapse
mode_unret_coll <- getmode(c1.collapse)
mean_unret_coll <- mean(c1.collapse)
mode_ret_coll <- getmode(c2.collapse)
mean_ret_coll <- mean(c2.collapse)

# Statistics for fatalities
mode_unret_fat <- getmode(unret_fat)
mean_unret_fat <- mean(unret_fat)
mode_ret_fat <- getmode(ret_fat)
mean_ret_fat <- mean(ret_fat)

# Calculate lives saved
# LivesSaved <- round(mean_unret_fat - mean_ret_fat)
LivesSaved <- round(mean_unret_fat) - round(mean_ret_fat) # Since I'm showing integers on the plot

# Total occupancy
tot.occ <- sum(c1.occ) # should be the same with either c1 or c2

# Number of fatalities if all buildings collapsed, with the assumed the fatality rate 
tot.fat <- tot.occ * fatality_rate

```

```{r}
# Reshape data frames for plotting
fatality_all <- data.frame(index = c(1:n),
                           Counterfactual=unret_fat,
                           Actual=ret_fat)
fatality.melt <- melt(fatality_all, id.vars = "index")
names(fatality.melt)=c("index","Building_state","Fatalities")


```



GGRIDGES - FATALITIES

```{r}
# Density plot with semi-transparent fill
library("scales")
ggplot(fatality.melt, aes(x=Fatalities, y=Building_state, fill=Building_state, color=Building_state)) +
  stat_density_ridges(aes(x=Fatalities),
                      quantile_lines=TRUE, quantile_fun=function(x,...)mean(x),
                      scale = 1,
                      alpha=1,
                      color="white",
                      bandwidth=10
                      )+
  scale_y_discrete(expand = c(0, 0)) + 
  scale_x_continuous(expand = c(0, 0)) +   # for both axes to remove unneeded padding
  #scale_fill_manual(values=c("#d7191c", "#2c7bb6"))+
  scale_fill_manual(values=c("#c41a00", "#142b5c"))+
  scale_color_manual(values=c("#c41a00", "#142b5c"))+
  guides(fill=FALSE, color=FALSE) + #remove legend
  coord_cartesian(clip = "off") + # to avoid clipping of the very top of the top ridgeline
  # geom_point(aes(x= mean_ret_fat, y=2 ), color = "black") +
  # geom_point(aes(x= mean_unret_fat, y=1 ), color = "black") +
  # geom_point(aes(x= mode_ret_fat, y=2 ), shape=17, size=2, color = "black") +
  # geom_point(aes(x= mode_unret_fat, y=1), shape=17, size=2, color = "black") +
  geom_segment(aes(x = mean_ret_fat, xend = mean_ret_fat, y=1, yend=2),
               linetype="dotted", 
               size=0.4, color = "grey80", alpha=0.1)+
  geom_segment(aes(x = mean_ret_fat, xend = mean_unret_fat, y=1.4, yend=1.4),
               arrow = arrow(length = unit(0.5, "cm")), linetype=1, size=0.4, color = "black")+
  geom_segment(aes(x = mean_unret_fat, xend = mean_ret_fat, y=1.4, yend=1.4),
               arrow = arrow(length = unit(0.5, "cm")), linetype=1, size=0.4, color = "black")+
  # geom_vline(xintercept = mean_ret_fat, alpha = 0.15)+
  # geom_vline(xintercept = mean_unret_fat, alpha = 0.15)+
  annotate(geom="text", x=280, y=1.55, label=paste("Estimated lives saved =", LivesSaved), color="black", angle=0) +
  annotate(geom="text", x=650, y=2.8, label="Estimates based on 10,000 simulations" , color="grey20", angle=0) +
  annotate(geom="text", x=590, y=2.65, label=paste("Assumed fatality rate =", fatality_rate), color="grey20", angle=0) +
  annotate(geom="text", x=580, y=2.5, label=paste("Total occupancy =", comma(tot.occ)), color="grey20", angle=0) +
  annotate(geom="text", x=660, y=2.35, label=paste("Fatalities if all buildings collapsed =", comma(tot.fat)), color="grey20", angle=0) +
  # annotate(geom="text", x=mode_unret_fat-27, y=1.1, label=paste(round(mode_unret_fat)), color="white", angle=0) +
  # annotate(geom="text", x=mode_ret_fat+12, y=2.1, label=paste(round(mode_ret_fat)), color="white", angle=0) +
  annotate(geom="text", x=mean_unret_fat+25, y=1.1, label=paste(round(mean_unret_fat)), color="white", angle=0) +
  annotate(geom="text", x=mean_ret_fat+27, y=2.1, label=paste(round(mean_ret_fat)), color="white", angle=0) +
  # annotate(geom="text", x=mode_unret_fat-31, y=1.2, label="mode", color="white", angle=0,  label.size = NA) +
  # annotate(geom="text", x=mode_ret_fat+31, y=2.2, label="mode", color="white", angle=0,  label.size = NA) +
  annotate(geom="text", x=mean_unret_fat+35, y=1.2, label="mean", color="white", angle=0,  label.size = NA) +
  annotate(geom="text", x=mean_ret_fat+35, y=2.2, label="mean", color="white", angle=0,  label.size = NA) +
  # annotate(geom="text", x=525, y=2.3, label="Actual case = All buildings were retrofitted" ) +
  # annotate(geom="text", x=610, y=2.2, label="Counterfactual case = All 70 buildings were not retrofitted" ) +
  xlim(c(0,850))+
  labs(y = "Scenario",
       title = paste("Estimated fatalities for", bldg_count, "school buildings (ShakeMap)"))+ 
  theme_ridges(center = TRUE, grid = FALSE)

ggsave(file= here("graphics", "results_fatalityplot_case1_shakemap_kernel_nomode.png") ,
       #plot = last_plot(),
       bg = "white",
       width = 7, height = 3,
       scale =1.2,
       dpi = 300)

```


```{r}
# Reshape data frames for plotting
collapse_all <- data.frame(index = c(1:n),
                           Counterfactual=c1.collapse,
                           Actual=c2.collapse)
collapse.melt <- melt(collapse_all, id.vars = "index")
names(collapse.melt)=c("index","Building_state","Collapsed_Buildings")

# Calculate building collapse saved
CollapseSaved <- round(mean_unret_coll - mean_ret_coll)

summary(ret_fat)

```


GGRIDGES - COLLAPSE

```{r}
# Density plot with semi-transparent fill
ggplot(collapse.melt, aes(x=Collapsed_Buildings, y=Building_state, fill=Building_state, color=Building_state)) +
  # stat_density_ridges(quantile_lines=TRUE, quantile_fun=function(x,...)mean(x),
  #                     scale = 1,
  #                     alpha=0.9,
  #                     bandwidth=5
  #                     )+
  geom_density_ridges(stat = "binline",
                      bins = 70,
                      binwidth=1,
                      scale = 0.95,
                      draw_baseline = F)+
  scale_y_discrete(expand = c(0, 0)) + 
  scale_x_continuous(expand = c(0, 0)) +   # for both axes to remove unneeded padding
  #scale_fill_manual(values=c("#d7191c", "#2c7bb6"))+
  scale_fill_manual(values=c("#c41a00", "#142b5c"))+
  scale_color_manual(values=c("#c41a00", "#142b5c"))+
  guides(fill=FALSE, color=FALSE) + #remove legend
  coord_cartesian(clip = "off") + # to avoid clipping of the very top of the top ridgeline
  geom_point(aes(x= mean_ret_coll, y=2 ), color = "black") +
  geom_point(aes(x= mean_unret_coll, y=1 ), color = "black") +
  geom_point(aes(x= mode_ret_coll, y=2 ), shape=17, size=2, color = "black") +
  geom_point(aes(x= mode_unret_coll, y=1), shape=17, size=2, color = "black") +
  geom_segment(aes(x = mean_ret_coll, xend = mean_unret_coll, y=1.6, yend=1.6),
               arrow = arrow(length = unit(0.5, "cm")), linetype=1, size=0.4, color = "black")+
  geom_segment(aes(x = mean_unret_coll, xend = mean_ret_coll, y=1.6, yend=1.6),
               arrow = arrow(length = unit(0.5, "cm")), linetype=1, size=0.4, color = "black")+
  geom_vline(xintercept = mean_ret_coll, alpha = 0.15)+
  geom_vline(xintercept = mean_unret_coll, alpha = 0.15)+
  annotate(geom="text", x=10, y=1.75, label=paste("Avoided collapse =", CollapseSaved), color="black", angle=0) +
  annotate(geom="text", x=25, y=2.8, label="Estimates based on 10,000 simulations" , color="grey20", angle=0) +
  #annotate(geom="text", x=21.5, y=2.6, label=paste("Total buildings =", bldg_count), color="grey20", angle=0) +
  annotate(geom="text", x=mode_unret_coll+1, y=1.1, label=paste(round(mode_unret_coll,1)), color="white", angle=0) +
  annotate(geom="text", x=mode_ret_coll-1, y=2.1, label=paste(round(mode_ret_coll,1)), color="white", angle=0) +
  annotate(geom="text", x=mean_unret_coll-1, y=1.1, label=paste(round(mean_unret_coll,1)), color="white", angle=0) +
  annotate(geom="text", x=mean_ret_coll+1, y=2.1, label=paste(round(mean_ret_coll,1)), color="white", angle=0) +
  annotate(geom="text", x=mode_unret_coll+1, y=1.2, label="mode", color="white", angle=0) +
  annotate(geom="text", x=mode_ret_coll-1, y=2.2, label="mode", color="white", angle=0) +
  annotate(geom="text", x=mean_unret_coll-1, y=1.2, label="mean", color="white", angle=0) +
  annotate(geom="text", x=mean_ret_coll+1, y=2.2, label="mean", color="white", angle=0) +
  #xlim(c(-20,993))+
  labs(y = "Scenario",
       x= "No. of collapsed buildings",
       title = paste("Estimated building collapse out of", bldg_count, "school buildings (ShakeMap)"))+ 
  theme_ridges(center = TRUE, grid = FALSE)

ggsave(file= here("graphics", "case1-shakemap-collapse.png") ,
       #plot = last_plot(),
       bg = "white",
       width = 7, height = 3,
       scale =1.2,
       dpi = 300)

```



Save RData
```{r}

save(c1.collapse, file = here("RData_case1_shakemap","c1.collapse.RData"))
save(c2.collapse, file = here("RData_case1_shakemap","c2.collapse.RData"))
save(unret_fat, file = here("RData_case1_shakemap","unret_fat.RData"))
save(ret_fat, file = here("RData_case1_shakemap","ret_fat.RData"))
save(c1.occ, file = here("RData_case1_shakemap","c1.occ.RData"))

```